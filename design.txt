# failure, nested components with non core sub components still don't work... :(:(:(
# start over as DSL / yaml config?
# basically higher levels are just search/replaced with combinational circuits plus special magic?
# back to ID/db idea?

next_step = adder substractor by adding a 'sub' 
if subtracting, take the 2's complement of the 2nd number first
that means inverting and passing a 1 into the first adder (make it full instead of half duh)

ports = [0,1,  gate1 output, gate2 output]


non-core components - set input pointer should actually update the child component's input pointer instead...
input_map = gate1 : [port idx...]
recursive...

clarify use of labels versus numbers...

build an N bit pc from scratch
really make it dynamic?

how to run efficiently?
	each 'component' should have multiple levels of operation?  'compile' low level components into functions/lambdas?

how to label, hook-up everything?

simulate a physical breadboard?

clock!

git
tests


how to avoid magic?  cna we use wires instead of grabbing and setting values between outer shell and inner components
could give each input a global id...
so 'magic' only happens at the lower level - physical devices
------


outputs are the ONLY actual true and false values
inputs are pointers to those outputs
but non-core components have input_pointers, which point to inputs.  
this allows you to externally set a component's input to a subcomponent's input.

signal                     or gate
. . [] [false]         [self,0] [sigfalse,0]       [false]   [self,0]
. . [] [true]          [self,1] [sigtrue,0]



input pointers
inputs (point to outputs)
output pointers
outputs

# FalseSignal [],[[self,0]],[false]
# TrueSignal [],[[self,0]],[false]
# OrGate 
	[[self,0],[self,1]],
	[[self,0]]
	,[false]

