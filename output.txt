Setup:

Sample program from prog1.src:
	SET value = 30
	SET plus = 10
	LDA value
	LDB plus
	ADD
	SUB
	SUB

This "program" was "compiled" into our machine language (prog1.rom) by compile.rb.
This machine code then gets pre-loaded into the computers "RAM", and then the simulation becomes.

-----------------------------------------------------------------
This is the start state of our computer.  Everything is basically zero except what is loaded into RAM.
We process micro-instruction(MI) 0, which sends the program counter (PC) to the memory address (RAM).  
This has no effect since it was already zero.
-----------------------------------------------------------------
Computer 1 start:
  A: 00000000 (0)  B: 00000000 (0)
ALU: 00000000 (0)
BUS: 00000000 (0)

MAR: 00000000
RAM: 00000100 (4)

PC:  00000000 (0)
IR:    000000 (RESET) 0000


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0

-----------------------------------------------------------------
Now we process MI 1, which copies RAM into the instruction register (IR).  
We also increment the program counter for later.
-----------------------------------------------------------------
Computer 1 before:
  A: 00000000 (0)  B: 00000000 (0)
ALU: 00000000 (0)
BUS: 00000100 (4)

MAR: 00000000
RAM: 00000100 (4)

PC:  00000000 (0)
IR:    000000 (RESET) 0001


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 0 1 0 1 0 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Now that LDA command is loaded into the IR, our microcode rom controls the computer to make that happen, starting with
micro-instruction 2.  On our computer, LDA requires a memory address to load from, which is a second instruction byte.
So we load the PC (which is now the current LDA instruction plus 1) into the MAR to prepare to grab it.
-----------------------------------------------------------------
Computer 1 before:
  A: 00000000 (0)  B: 00000000 (0)
ALU: 00000000 (0)
BUS: 00000001 (1)

MAR: 00000000
RAM: 00000100 (4)

PC:  00000001 (1)
IR:    000100 (LDA) 0010


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0
-----------------------------------------------------------------
The value stored there isn't the actual value but a memory address where the value is stored.  
So micro-instruction 3 puts the address at that memory location (201) back into the MAR to dereference it.
We also take the take to increment the PC.  This instruction doens't need any more data but we need to get ready for the 
next instruction.  
-----------------------------------------------------------------
Computer 1 before:
  A: 00000000 (0)  B: 00000000 (0)
ALU: 00000000 (0)
BUS: 11001001 (201)

MAR: 00000001
RAM: 11001001 (201)

PC:  00000001 (1)
IR:    000100 (LDA) 0011


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 1 0 0 0 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Lastly, grab the value from ram (30), store it in the A register.  Our instruction is now done! 
So we also trigger micro-instruction zero (MCZ) to start the next instruction.
-----------------------------------------------------------------
Computer 1 before:
  A: 00000000 (0)  B: 00000000 (0)
ALU: 00000000 (0)
BUS: 00011110 (30)

MAR: 11001001
RAM: 00011110 (30)

PC:  00000010 (2)
IR:    000100 (LDA) 0100


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:1 0 0 0 0 0 1 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Back at MI 0, we now load the PC (2) into the MAR so we can get the next opcode out of RAM.  Remember the PC is at memory
address 2 because the first instruction required two bytes (0 for the LDA opcode and 1 for the memory address).
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00000000 (0)
ALU: 00011110 (30)
BUS: 00000010 (2)

MAR: 11001001
RAM: 00011110 (30)

PC:  00000010 (2)
IR:    000100 (LDA) 0000


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0
-----------------------------------------------------------------
MI 1 is to move the opcode from RAM into the IR.  We have an LDB instruction.
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00000000 (0)
ALU: 00011110 (30)
BUS: 00000101 (5)

MAR: 00000010
RAM: 00000101 (5)

PC:  00000010 (2)
IR:    000100 (LDA) 0001


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 0 1 0 1 0 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
LDB also has an address stored at the next byte, so load that into the MAR from the PC.
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00000000 (0)
ALU: 00011110 (30)
BUS: 00000011 (3)

MAR: 00000010
RAM: 00000101 (5)

PC:  00000011 (3)
IR:    000101 (LDB) 0010


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0
-----------------------------------------------------------------
Use the MAR to dereference that address in RAM.
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00000000 (0)
ALU: 00011110 (30)
BUS: 11001010 (202)

MAR: 00000011
RAM: 11001010 (202)

PC:  00000011 (3)
IR:    000101 (LDB) 0011


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 1 0 0 0 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Now store the actual value at address 202 (10) into register B.
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00000000 (0)
ALU: 00011110 (30)
BUS: 00001010 (10)

MAR: 11001010
RAM: 00001010 (10)

PC:  00000100 (4)
IR:    000101 (LDB) 0100


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 1 0 0 0 0 1 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Back at MI 0, lookup the next instruction by loading the PC into the MAR
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00001010 (10)
ALU: 00101000 (40)
BUS: 00000100 (4)

MAR: 11001010
RAM: 00001010 (10)

PC:  00000100 (4)
IR:    000101 (LDB) 0000


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0
-----------------------------------------------------------------
..then RAM into the IR.
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00001010 (10)
ALU: 00101000 (40)
BUS: 00100000 (32)

MAR: 00000100
RAM: 00100000 (32)

PC:  00000100 (4)
IR:    000101 (LDB) 0001


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 0 1 0 1 0 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Looks like we have an ADD instruction.  This instruction is only a single byte; it should add registers A and B and
store the result in A.  And we can do that in a single instruction.  The Arithmetic logic unit (ALU) is constantly adding 
A and B so we simply need to store the output in A register.
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00001010 (10)
ALU: 00101000 (40)
BUS: 00101000 (40)

MAR: 00000100
RAM: 00100000 (32)

PC:  00000101 (5)
IR:    100000 (ADD) 0010


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:1 0 0 0 0 0 1 0     CTL SEND: 0 0 0 0 1 0 0 0
-----------------------------------------------------------------
Onto MI 0 and the next instruction.
-----------------------------------------------------------------
Computer 1 before:
  A: 00101000 (40)  B: 00001010 (10)
ALU: 00110010 (50)
BUS: 00000101 (5)

MAR: 00000100
RAM: 00100000 (32)

PC:  00000101 (5)
IR:    100000 (ADD) 0000


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0
-----------------------------------------------------------------
Load it into the IR for decoding.
-----------------------------------------------------------------
Computer 1 before:
  A: 00101000 (40)  B: 00001010 (10)
ALU: 00110010 (50)
BUS: 00100001 (33)

MAR: 00000101
RAM: 00100001 (33)

PC:  00000101 (5)
IR:    100000 (ADD) 0001


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 0 1 0 1 0 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Looks like we have a SUB operand for subtraction.  It should perform A - B and store the result in A.
It works the same way as ADD, it requires no extra parameter and only a single instruction.  The only
difference is setting the subtraction flag on the ALU.
-----------------------------------------------------------------
Computer 1 before:
  A: 00101000 (40)  B: 00001010 (10)
ALU: 00011110 (30)
BUS: 00011110 (30)

MAR: 00000101
RAM: 00100001 (33)

PC:  00000110 (6)
IR:    100001 (SUB) 0010


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:1 0 0 0 0 0 1 0     CTL SEND: 0 0 0 0 1 1 0 0
-----------------------------------------------------------------
Now A is storing 30 (which is 30 + 10 - 10).  Continue with MI 0.
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00001010 (10)
ALU: 00101000 (40)
BUS: 00000110 (6)

MAR: 00000101
RAM: 00100001 (33)

PC:  00000110 (6)
IR:    100001 (SUB) 0000


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0
-----------------------------------------------------------------
And MI 1
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00001010 (10)
ALU: 00101000 (40)
BUS: 00100001 (33)

MAR: 00000110
RAM: 00100001 (33)

PC:  00000110 (6)
IR:    100001 (SUB) 0001


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 0 1 0 1 0 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Looks like we have a second subtraction command.  Now 20 should end up in A register.
-----------------------------------------------------------------
Computer 1 before:
  A: 00011110 (30)  B: 00001010 (10)
ALU: 00010100 (20)
BUS: 00010100 (20)

MAR: 00000110
RAM: 00100001 (33)

PC:  00000111 (7)
IR:    100001 (SUB) 0010


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:1 0 0 0 0 0 1 0     CTL SEND: 0 0 0 0 1 1 0 0
-----------------------------------------------------------------
And it does.  A now has (30 + 10 - 10 - 10 = 20) just as requested.
-----------------------------------------------------------------
Computer 1 before:
  A: 00010100 (20)  B: 00001010 (10)
ALU: 00011110 (30)
BUS: 00000111 (7)

MAR: 00000110
RAM: 00100001 (33)

PC:  00000111 (7)
IR:    100001 (SUB) 0000


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0
-----------------------------------------------------------------
Now MI 0 to load the next command.
-----------------------------------------------------------------
Computer 1 before:
  A: 00010100 (20)  B: 00001010 (10)
ALU: 00011110 (30)
BUS: 00000000 (0)

MAR: 00000111
RAM: 00000000 (0)

PC:  00000111 (7)
IR:    100001 (SUB) 0001


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 0 1 0 1 0 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
And MI 1 to put it into the PC.
-----------------------------------------------------------------
Computer 1 before:
  A: 00010100 (20)  B: 00001010 (10)
ALU: 00011110 (30)
BUS: 00000000 (0)

MAR: 00000111
RAM: 00000000 (0)

PC:  00001000 (8)
IR:    000000 (RESET) 0010


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:1 1 0 1 1 0 1 0     CTL SEND: 0 0 0 0 0 0 0 1
-----------------------------------------------------------------
Looks like its a RESET operand.  This is a special operand that basically
says our program is over, by copying 0s into the PC.  Our program will now
basically run again from the top, but we can stop simulating it because we're done.
-----------------------------------------------------------------
Computer 1 before:
  A: 00000000 (0)  B: 00000000 (0)
ALU: 00000000 (0)
BUS: 00000000 (0)

MAR: 00000111
RAM: 00000000 (0)

PC:  00000000 (0)
IR:    000000 (RESET) 0000


             M   J   M R                       A S   R     
             A C M I C A                     P L U   A     
         A B R E P R Z M               A B   C U B   M     
CTL RECV:0 0 1 0 0 0 0 0     CTL SEND: 0 0 0 1 0 0 0 0
-----------------------------------------------------------------

-----------------------------------------------------------------
